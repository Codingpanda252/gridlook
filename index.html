<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
		<title>gridlook - ICON native grid viewer</title>
		<style>
			body { margin: 0; }
		</style>
        <link rel="stylesheet" href="css/bulma.min.css">
        <link rel="stylesheet" href="css/gridlook.css">
        <link href="static/fontawesome-free-6.1.1-web/css/all.css" rel="stylesheet">
	</head>
	<body>
        <nav class="panel gl_controls" id="main_controls">
          <div class="panel-heading" style="display: flex; justify-content: space-between;">
          <div>
          {{ model_info.title }}
          </div>
          <div>
              <i class="fa-solid" :class="{'fa-angle-down': menu_collapsed, 'fa-angle-up': !menu_collapsed}" @click="toggle_collapsed"></i>
          </div>
          </div>
          <div class="panel-block" :class="{'is-hidden': menu_collapsed}">
            <select class="form-control" v-model="varname">
              <option v-for="varname in Object.keys(model_info.vars)" :value="varname" :key="varname">{{ varname }}</option>
            </select>
            &nbsp;
            <select class="form-control" v-model="colormap">
              <option v-for="cm in model_info.colormaps" :value="cm" :key="cm">{{ cm }}</option>
            </select>
            &nbsp;
            <input type="checkbox" v-model="invert_colormap" id="invert_colormap"></input><label for="invert_colormap">invert</label>
          </div>
          <div class="panel-block" :class="{'is-hidden': menu_collapsed}">
            <p class="control">
            time: {{ time_index }} / {{ model_info.time_range.end }}
            <input class="input"
                   type="range"
                   v-bind:min="model_info.time_range.start"
                   v-bind:max="model_info.time_range.end"
                   v-model.number="time_index">
            currently shown: {{ current_var_name }} @ {{ current_time_index }} <br/>
            {{ current_var_attrs.long_name }} / {{ current_var_attrs.units }}
            </p>
          </div>
          <div class="panel-block" :class="{'is-hidden': menu_collapsed}">
            <table>
                <tr>
                    <th>range</th><th>low</th><th>high</th>
                </tr>
                <tr>
                    <td><input type="radio" id="data_bounds" value="data" v-model="picked_bounds" /><label for="data_bounds">data</label></td>
                    <td>{{ Number(data_bounds.low).toPrecision(4) }}</td>
                    <td>{{ Number(data_bounds.high).toPrecision(4) }}</td>
                </tr>
                <tr>
                    <td><input type="radio" id="default_bounds" value="default" v-model="picked_bounds" /><label for="default_bounds">default</label></td>
                    <td>{{ Number(default_bounds.low).toPrecision(2) }}</td>
                    <td>{{ Number(default_bounds.high).toPrecision(2) }}</td>
                </tr>
                <tr>
                    <td><input type="radio" id="user_bounds" value="user" v-model="picked_bounds" /><label for="user_bounds">user</label></td>
                    <td><input size="10" v-model.number="user_bounds_low"/></td>
                    <td><input size="10" v-model.number="user_bounds_high"/></td>
                </tr>
            </table>
          </div>
          <div class="panel-block" :class="{'is-hidden': menu_collapsed}">
            <p class="control">
            <input type="checkbox" v-model="enable_coastlines" id="enable_coastlines"></input><label for="enable_coastlines">coastlines</label>
            </p>
            <p class="control">
            <button v-on:click="snapshot('globe')">Snapshot</button>
            </p>
          </div>
        </nav>
        <canvas id="globe">
        </canvas>
    </body>
    <script src="https://unpkg.com/vue@next"></script>
    <script src="js/three.js"></script>
    <script src="js/js-colormaps.js"></script>
    <script src="js/world_controls.js"></script>
    <script src="js/gridlook.js"></script>
    <script src="js/colormap_shaders.js"></script>
    <script src="js/geojson.js"></script>
    <script  type="module">
        import { HTTPStore, openArray, openGroup } from "https://cdn.skypack.dev/zarr";
        async function run() {

        const scene = new THREE.Scene();
        const center = new THREE.Vector3();
        const camera = new THREE.PerspectiveCamera( 7.5, window.innerWidth / window.innerHeight, 0.1, 1000 );

        const globe_canvas = document.getElementById("globe");
        const renderer = new THREE.WebGLRenderer({canvas: globe_canvas});
        renderer.setSize( window.innerWidth, window.innerHeight );

        //const datasources = await fetch("static/index_R02B06.json").then(r => r.json());
        //const datasources = await fetch("static/index_multires.json").then(r => r.json());
        const datasources = await fetch("static/index_mr_dpp0066.json").then(r => r.json());
        console.log(datasources);
        const store = new HTTPStore(datasources.levels[0].grid.store);


        const model_info = {
            title: datasources.name,
            vars: datasources.levels[0].datasources,
            default_var: datasources.default_var,
            colormaps: Object.keys(available_colormaps),
            time_range: {
                start: 0,
                end: 1
            }
        }

        const MainControls = {
          data() {
            return {
              menu_collapsed: false,
              time_index: 1,
              model_info: model_info,
              current_time_index: 1,
              current_var_name: "-",
              current_var_attrs: {},
              enable_coastlines: true,
              varname: model_info.default_var || Object.keys(model_info.vars)[0],
              colormap: "turbo",
              invert_colormap: true,
              data_bounds: {low: undefined, high: undefined},
              default_bounds: {low: undefined, high: undefined},
              user_bounds_low: undefined,
              user_bounds_high: undefined,
              picked_bounds: "data",
              view: {},
            }
          },
          watch: {
            time_index() {
                updateData(this.time_index, this.varname);
            },
            varname() {
                updateData(this.time_index, this.varname);
                const varinfo = this.model_info.vars[this.varname];
                this.default_bounds = varinfo.default_range || {low: undefined, high: undefined};
            },
            colormap() {
                updateColormap();
            },
            invert_colormap() {
                updateColormap();
            },
            picked_bounds() {
                updateColormap();
            },
            data_bounds() {
                updateColormap();
            },
            default_bounds() {
                updateColormap();
            },
            user_bounds_low() {
                updateColormap();
            },
            user_bounds_high() {
                updateColormap();
            },
            enable_coastlines() {
                if (this.enable_coastlines) {
                    scene.add(coast);
                } else {
                    scene.remove(coast);
                }
                render();
            },
          },
          methods: {
            snapshot(canvas_id) {
                snapshot(canvas_id, render);
            },
            toggle_collapsed() {
                this.menu_collapsed = !this.menu_collapsed;
            }
          },
          computed: {
            bounds() {
              if (this.picked_bounds == "data") {
                return this.data_bounds;
              }
              else if (this.picked_bounds == "default") {
                return this.default_bounds;
              }
              else if (this.picked_bounds == "user") {
                return {low: this.user_bounds_low, high: this.user_bounds_high};
              }
            }
          }
        }

        const main_controls = Vue.createApp(MainControls).mount('#main_controls');

        camera.up = new THREE.Vector3(0, 0, 1);
        camera.position.x = 30;
        camera.lookAt(center);

        const geometry = new THREE.BufferGeometry();

        function get_colormap_material() {
            if (main_controls.invert_colormap) {
                return make_colormap_material(main_controls.colormap, 1.0, -1.0);
            } else {
                return make_colormap_material(main_controls.colormap, 0.0, 1.0);
            }
        }

        let main_mesh;
        let lut_mesh;

        async function fetchGrid(grid, plotdata, colormap) {
            const [verts, values] = await Promise.all([
                grid2buffer(grid),
                data2value_buffer(plotdata)
            ]);

            console.log("verts have nan: " + verts.some(isNaN));

            geometry.setAttribute( 'position', new THREE.BufferAttribute( verts, 3 ) );
            geometry.setAttribute( 'data_value', new THREE.BufferAttribute( values.data_values, 1 ) );

            main_controls.data_bounds = {low: values.data_min, high: values.data_max};

            //const material = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide, vertexColors: THREE.VertexColors } );
            const material = get_colormap_material();
            main_mesh = new THREE.Mesh( geometry, material );
            scene.add(main_mesh);

            const lut_material = make_lut_material(main_controls.colormap, 1., -1.0);
            const lut_geometry = make_lut_geometry();
            lut_mesh = new THREE.Mesh( lut_geometry, lut_material );
            scene.add(lut_mesh);
            updateColormap();

            // redraw();  // done by updateColormap, may not be optimal
        }

        let grid;
        let datavars = {};

        async function getDataVar(varname) {
            if (datavars[varname] === undefined) {
                console.log("fetching " + varname);
                const datasource = datasources.levels[0].datasources[varname];
                const datastore = new HTTPStore(datasource.store);
                datavars[varname] = await openGroup(datastore, datasource.dataset, "r").then(ds => ds.getItem(varname));
            }
            console.log(datavars[varname]);
            return datavars[varname];
        }

        async function getData() {
            grid = await openGroup(store, datasources.levels[0].grid.dataset, "r");
            const varname = main_controls.varname;
            const datavar = await getDataVar(varname);
            main_controls.model_info.time_range.end = datavar.shape[0] - 1;
            await fetchGrid(grid, datavar.getRaw(1), "turbo_r");
            main_controls.current_var_attrs = await datavar.attrs.asObject();
            main_controls.current_time_index = 1;
            main_controls.current_var_name = varname;
        }

        let coast = undefined;
        async function getCoastlines() {
            const coastlines = await fetch("static/ne_50m_coastline.geojson").then(r => r.json());
            console.log(coastlines);
            const geometry = geojson2geometry(coastlines, 1.001);
            const material = new THREE.LineBasicMaterial( { color: "#ffffff" } );
            coast = new THREE.LineSegments( geometry, material );
            coast.name = "coastlines";
            scene.add(coast);
            redraw();
        }

        async function _updateData(time_index, varname) {
            console.log(varname);
            const datavar = await getDataVar(varname);
            console.log(datavar);
            const values = await data2value_buffer(datavar.getRaw(time_index))
            geometry.setAttribute( 'data_value', new THREE.BufferAttribute( values.data_values, 1 ) );
            main_controls.data_bounds = {low: values.data_min, high: values.data_max};

            redraw();
            main_controls.current_var_attrs = await datavar.attrs.asObject();
            main_controls.current_time_index = time_index;
            main_controls.current_var_name = varname;
            if (next_time_index == time_index && next_var_name == varname) next_time_index = undefined;
        }

        let next_time_index = undefined;
        let next_var_name = undefined;
        async function updateData(time_index, varname, force=false) {
            const run_now = force || next_time_index === undefined;
            if (!force) {
                next_time_index = time_index;
                next_var_name = varname;
            }
            if (run_now) {
                await _updateData(time_index, varname);
                if (next_time_index !== undefined) {
                    updateData(next_time_index, next_var_name, true);
                }
            }
        }

        async function updateColormap() {
            const low = main_controls.bounds.low;
            const high = main_controls.bounds.high;

            let data_add_offset;
            let data_scale_factor;
            let lut_add_offset;
            let lut_scale_factor;

            if (main_controls.invert_colormap) {
                data_scale_factor = -1. / (high - low);
                data_add_offset = -high * data_scale_factor;
                lut_add_offset = 1.;
                lut_scale_factor = -1.;
            } else {
                data_scale_factor = 1. / (high - low);
                data_add_offset = -low * data_scale_factor;
                lut_add_offset = 0.;
                lut_scale_factor = 1.;
            }

            [main_mesh, lut_mesh].map(mesh => {
                mesh.material.uniforms.colormap.value = available_colormaps[main_controls.colormap];
            });
            [main_mesh].map(mesh => {
                mesh.material.uniforms.add_offset.value = data_add_offset;
                mesh.material.uniforms.scale_factor.value = data_scale_factor;
            });
            [lut_mesh].map(mesh => {
                mesh.material.uniforms.add_offset.value = lut_add_offset;
                mesh.material.uniforms.scale_factor.value = lut_scale_factor;
            });
            redraw();
        }
    
        getData();
        getCoastlines();


        function render() {
            renderer.render(scene, camera);
        }

        var frameId = 0;
        function redraw() {
            cancelAnimationFrame(frameId);
            frameId = requestAnimationFrame(render);
        }

        attachControls(renderer, camera, center, redraw);

        function onWindowResize() {

            const aspect = window.innerWidth / window.innerHeight;

            camera.aspect = aspect;
            camera.updateProjectionMatrix();

            //cameraOrtho.left = cameraOrtho.bottom * aspect;
            //cameraOrtho.right = cameraOrtho.top * aspect;
            //cameraOrtho.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

            render();

        }

        redraw();
        window.addEventListener( 'resize', onWindowResize );
        };
        run();

    </script>
</html>
