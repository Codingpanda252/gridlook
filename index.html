<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>gridlook - ICON native grid viewer</title>
		<style>
			body { margin: 0; }
		</style>
        <link rel="stylesheet" href="css/bulma.min.css">
        <link rel="stylesheet" href="css/gridlook.css">
	</head>
	<body>
        <nav class="panel gl_controls" id="main_controls">
          <p class="panel-heading">
          {{ model_info.varname }}
          </p>
          <div class="panel-block">
            <p class="control">
            time: {{ time_index }} / {{ model_info.time_range.end }}
            <input class="input"
                   type="range"
                   v-bind:min="model_info.time_range.start"
                   v-bind:max="model_info.time_range.end"
                   v-model.number="time_index">
            currently shown: {{ current_time_index }}
            </p>
          </div>
          <div class="panel-block">
            <p class="control">
            <input type="checkbox" v-model="enable_coastlines" id="enable_coastlines"></input><label for="enable_coastlines">coastlines</label>
            </p>
            <p class="control">
            <button v-on:click="snapshot('globe')">Snapshot</button>
            </p>
          </div>
        </nav>
        <canvas id="globe">
        </canvas>
    </body>
    <script src="https://unpkg.com/vue@next"></script>
    <script src="js/three.js"></script>
    <script src="js/js-colormaps.js"></script>
    <script src="js/world_controls.js"></script>
    <script src="js/gridlook.js"></script>
    <script src="js/geojson.js"></script>
    <script  type="module">
        import { HTTPStore, openArray, openGroup } from "https://cdn.skypack.dev/zarr";
        const store = new HTTPStore("https://swift.dkrz.de/v1/dkrz_948e7d4bbfbb445fbff5315fc433e36a/nextGEMS/");

        const scene = new THREE.Scene();
        const center = new THREE.Vector3();
        const camera = new THREE.PerspectiveCamera( 7.5, window.innerWidth / window.innerHeight, 0.1, 1000 );

        const globe_canvas = document.getElementById("globe");
        const renderer = new THREE.WebGLRenderer({canvas: globe_canvas});
        renderer.setSize( window.innerWidth, window.innerHeight );

        // const geometry = new THREE.BoxGeometry();
        // const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
        // const cube = new THREE.Mesh( geometry, material );
        // scene.add( cube );

        const model_info = {
            varname: "prw",
            time_range: {
                start: 0,
                end: 1
            }
        }

        const MainControls = {
          data() {
            return {
              time_index: 1,
              model_info: model_info,
              current_time_index: 1,
              enable_coastlines: true,
            }
          },
          watch: {
            time_index() {
                updateData(this.time_index);
            },
            enable_coastlines() {
                if (this.enable_coastlines) {
                    scene.add(coast);
                } else {
                    scene.remove(coast);
                }
                render();
            },
          },
          methods: {
            snapshot(canvas_id) {
                snapshot(canvas_id, render);
            }
          }
        }

        const main_controls = Vue.createApp(MainControls).mount('#main_controls');

        camera.up = new THREE.Vector3(0, 0, 1);
        camera.position.x = 30;
        camera.lookAt(center);

        const geometry = new THREE.BufferGeometry();

        async function fetchGrid(grid, plotdata, colormap) {
            const [verts, values] = await Promise.all([
                grid2buffer(grid),
                data2value_buffer(plotdata)
            ]);

            console.log("verts have nan: " + verts.some(isNaN));

            geometry.setAttribute( 'position', new THREE.BufferAttribute( verts, 3 ) );
            geometry.setAttribute( 'data_value', new THREE.BufferAttribute( values, 1 ) );

            //const material = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide, vertexColors: THREE.VertexColors } );
            const material = make_colormap_material("turbo", 1.0, -1.0);
            const mesh = new THREE.Mesh( geometry, material );
            scene.add(mesh);

            redraw();
        }

        let grid;
        let datavar;
        async function getData() {
            grid = await openGroup(store, "grids/ICON_R02B06.zarr", "r");
            datavar = await openGroup(store, "nextGEMS_ICON_3d_prw_R02B06.zarr", "r").then(ds => ds.getItem(model_info.varname));
            main_controls.model_info.time_range.end = datavar.shape[0] - 1;
            await fetchGrid(grid, datavar.getRaw(1), "turbo_r");
            main_controls.current_time_index = 1;
        }

        let coast = undefined;
        async function getCoastlines() {
            const coastlines = await fetch("static/ne_50m_coastline.geojson").then(r => r.json());
            console.log(coastlines);
            const geometry = geojson2geometry(coastlines, 1.001);
            const material = new THREE.LineBasicMaterial( { color: "#ffffff" } );
            coast = new THREE.LineSegments( geometry, material );
            coast.name = "coastlines";
            scene.add(coast);
            redraw();
        }

        async function _updateData(time_index) {
            const values = await data2value_buffer(datavar.getRaw(time_index))
            geometry.setAttribute( 'data_value', new THREE.BufferAttribute( values, 1 ) );

            redraw();
            main_controls.current_time_index = time_index;
            if (next_time_index == time_index) next_time_index = undefined;
        }

        let next_time_index = undefined;
        async function updateData(time_index, force=false) {
            const run_now = force ||Â next_time_index === undefined;
            if (!force) next_time_index = time_index;
            if (run_now) {
                await _updateData(time_index);
                if (next_time_index !== undefined) {
                    updateData(next_time_index, true);
                }
            }
        }
    
        getData();
        getCoastlines();


        function render() {
            renderer.render(scene, camera);
        }

        var frameId = 0;
        function redraw() {
            cancelAnimationFrame(frameId);
            frameId = requestAnimationFrame(render);
        }

        attachControls(renderer, camera, center, redraw);

        function onWindowResize() {

            const aspect = window.innerWidth / window.innerHeight;

            camera.aspect = aspect;
            camera.updateProjectionMatrix();

            //cameraOrtho.left = cameraOrtho.bottom * aspect;
            //cameraOrtho.right = cameraOrtho.top * aspect;
            //cameraOrtho.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

            render();

        }

        redraw();
        window.addEventListener( 'resize', onWindowResize );

    </script>
</html>
