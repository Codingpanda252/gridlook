<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>gridlook - ICON native grid viewer</title>
		<style>
			body { margin: 0; }
		</style>
        <link rel="stylesheet" href="css/bulma.min.css">
        <link rel="stylesheet" href="css/gridlook.css">
	</head>
	<body>
        <nav class="panel gl_controls" id="main_controls">
          <p class="panel-heading">
          {{ model_info.title }}
          </p>
          <div class="panel-block">
            <select class="form-control" v-model="varname">
              <option v-for="varname in model_info.vars" :value="varname" :key="varname">{{ varname }}</option>
            </select>
            &nbsp;
            <select class="form-control" v-model="colormap">
              <option v-for="cm in model_info.colormaps" :value="cm" :key="cm">{{ cm }}</option>
            </select>
            &nbsp;
            <input type="checkbox" v-model="invert_colormap" id="invert_colormap"></input><label for="invert_colormap">invert</label>
          </div>
          <div class="panel-block">
            <p class="control">
            time: {{ time_index }} / {{ model_info.time_range.end }}
            <input class="input"
                   type="range"
                   v-bind:min="model_info.time_range.start"
                   v-bind:max="model_info.time_range.end"
                   v-model.number="time_index">
            currently shown: {{ current_var_name }} @ {{ current_time_index }}
            </p>
          </div>
          <div class="panel-block">
            <p class="control">
            <input type="checkbox" v-model="enable_coastlines" id="enable_coastlines"></input><label for="enable_coastlines">coastlines</label>
            </p>
            <p class="control">
            <button v-on:click="snapshot('globe')">Snapshot</button>
            </p>
          </div>
        </nav>
        <canvas id="globe">
        </canvas>
    </body>
    <script src="https://unpkg.com/vue@next"></script>
    <script src="js/three.js"></script>
    <script src="js/js-colormaps.js"></script>
    <script src="js/world_controls.js"></script>
    <script src="js/gridlook.js"></script>
    <script src="js/geojson.js"></script>
    <script  type="module">
        import { HTTPStore, openArray, openGroup } from "https://cdn.skypack.dev/zarr";

        const scene = new THREE.Scene();
        const center = new THREE.Vector3();
        const camera = new THREE.PerspectiveCamera( 7.5, window.innerWidth / window.innerHeight, 0.1, 1000 );

        const globe_canvas = document.getElementById("globe");
        const renderer = new THREE.WebGLRenderer({canvas: globe_canvas});
        renderer.setSize( window.innerWidth, window.innerHeight );

        //const datasources = await fetch("static/index_R02B06.json").then(r => r.json());
        //const datasources = await fetch("static/index_multires.json").then(r => r.json());
        const datasources = await fetch("static/index_mr_dpp0066.json").then(r => r.json());
        console.log(datasources);
        const store = new HTTPStore(datasources.levels[0].grid.store);


        const model_info = {
            title: datasources.name,
            vars: Object.keys(datasources.levels[0].datasources),
            default_var: datasources.default_var,
            colormaps: Object.keys(available_colormaps),
            time_range: {
                start: 0,
                end: 1
            }
        }

        const MainControls = {
          data() {
            return {
              time_index: 1,
              model_info: model_info,
              current_time_index: 1,
              current_var_name: "-",
              enable_coastlines: true,
              varname: model_info.default_var || model_info.vars[0],
              colormap: "turbo",
              invert_colormap: true,
              view: {},
            }
          },
          watch: {
            time_index() {
                updateData(this.time_index, this.varname);
            },
            varname() {
                updateData(this.time_index, this.varname);
            },
            colormap() {
                updateColormap();
            },
            invert_colormap() {
                updateColormap();
            },
            enable_coastlines() {
                if (this.enable_coastlines) {
                    scene.add(coast);
                } else {
                    scene.remove(coast);
                }
                render();
            },
          },
          methods: {
            snapshot(canvas_id) {
                snapshot(canvas_id, render);
            }
          }
        }

        const main_controls = Vue.createApp(MainControls).mount('#main_controls');

        camera.up = new THREE.Vector3(0, 0, 1);
        camera.position.x = 30;
        camera.lookAt(center);

        const geometry = new THREE.BufferGeometry();

        function get_colormap_material() {
            if (main_controls.invert_colormap) {
                return make_colormap_material(main_controls.colormap, 1.0, -1.0);
            } else {
                return make_colormap_material(main_controls.colormap, 0.0, 1.0);
            }
        }

        let main_mesh;

        async function fetchGrid(grid, plotdata, colormap) {
            const [verts, values] = await Promise.all([
                grid2buffer(grid),
                data2value_buffer(plotdata)
            ]);

            console.log("verts have nan: " + verts.some(isNaN));

            geometry.setAttribute( 'position', new THREE.BufferAttribute( verts, 3 ) );
            geometry.setAttribute( 'data_value', new THREE.BufferAttribute( values, 1 ) );

            //const material = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide, vertexColors: THREE.VertexColors } );
            const material = get_colormap_material();
            main_mesh = new THREE.Mesh( geometry, material );
            scene.add(main_mesh);

            redraw();
        }

        let grid;
        let datavars = {};

        async function getDataVar(varname) {
            if (datavars[varname] === undefined) {
                console.log("fetching " + varname);
                const datasource = datasources.levels[0].datasources[varname];
                const datastore = new HTTPStore(datasource.store);
                datavars[varname] = await openGroup(datastore, datasource.dataset, "r").then(ds => ds.getItem(varname));
            }
            return datavars[varname];
        }

        async function getData() {
            grid = await openGroup(store, datasources.levels[0].grid.dataset, "r");
            const varname = main_controls.varname;
            const datavar = await getDataVar(varname);
            main_controls.model_info.time_range.end = datavar.shape[0] - 1;
            await fetchGrid(grid, datavar.getRaw(1), "turbo_r");
            main_controls.current_time_index = 1;
            main_controls.current_var_name = varname;
        }

        let coast = undefined;
        async function getCoastlines() {
            const coastlines = await fetch("static/ne_50m_coastline.geojson").then(r => r.json());
            console.log(coastlines);
            const geometry = geojson2geometry(coastlines, 1.001);
            const material = new THREE.LineBasicMaterial( { color: "#ffffff" } );
            coast = new THREE.LineSegments( geometry, material );
            coast.name = "coastlines";
            scene.add(coast);
            redraw();
        }

        async function _updateData(time_index, varname) {
            console.log(varname);
            const datavar = await getDataVar(varname);
            console.log(datavar);
            const values = await data2value_buffer(datavar.getRaw(time_index))
            geometry.setAttribute( 'data_value', new THREE.BufferAttribute( values, 1 ) );

            redraw();
            main_controls.current_time_index = time_index;
            main_controls.current_var_name = varname;
            if (next_time_index == time_index) next_time_index = undefined;
            if (next_var_name == varname) next_var_name = undefined;
        }

        let next_time_index = undefined;
        let next_var_name = undefined;
        async function updateData(time_index, varname, force=false) {
            const run_now = force || next_time_index === undefined || next_var_name === undefined;
            if (!force) {
                next_time_index = time_index;
                next_var_name = varname;
            }
            if (run_now) {
                await _updateData(time_index, varname);
                if (next_time_index !== undefined || next_var_name !== undefined) {
                    updateData(next_time_index, varname, true);
                }
            }
        }

        async function updateColormap() {
            main_mesh.material.uniforms.colormap.value = available_colormaps[main_controls.colormap];
            if (main_controls.invert_colormap) {
                main_mesh.material.uniforms.add_offset.value = 1.0;
                main_mesh.material.uniforms.scale_factor.value = -1.0;
            } else {
                main_mesh.material.uniforms.add_offset.value = 0.0;
                main_mesh.material.uniforms.scale_factor.value = 1.0;
            }
            redraw();
        }
    
        getData();
        getCoastlines();


        function render() {
            renderer.render(scene, camera);
        }

        var frameId = 0;
        function redraw() {
            cancelAnimationFrame(frameId);
            frameId = requestAnimationFrame(render);
        }

        attachControls(renderer, camera, center, redraw);

        function onWindowResize() {

            const aspect = window.innerWidth / window.innerHeight;

            camera.aspect = aspect;
            camera.updateProjectionMatrix();

            //cameraOrtho.left = cameraOrtho.bottom * aspect;
            //cameraOrtho.right = cameraOrtho.top * aspect;
            //cameraOrtho.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

            render();

        }

        redraw();
        window.addEventListener( 'resize', onWindowResize );

    </script>
</html>
